import random
import pandas as pd
import matplotlib.pyplot as plt
import numpy as np


""" 1) Этап задания: Получить Dataset (данные)________________________________________________"""

# генерируем численные данные с помощью генератора случайных чисел
my_dataset = random.choices(range(-10000,10001), k = 1000)
# верхний диапазон ставим до 10001, что бы число 100000 шло включительно, так как стандартный интервал range в Python
# включает начальное число, но не включает конечное

""" 2) Этап задания: Рассчитать стандартные числовые характеристики для набора данных Series________________________"""

# формируем объект Series
series_dataset = pd.Series(my_dataset)


# определим минимальное значение с помощью встроенной функции min()
Series_min = min(series_dataset)
print("Минимальное значение:",Series_min)


# определим количество повторяющихся значений
frequent_values = series_dataset.value_counts()[lambda x: x > 1].index
""" Пояснение:
1 - Получаем количество повторений каждого значения с помощью метода (из библиотеки Pandas) value_counts(). 
Метод value_counts() применяется к объекту Series и возвращает новый объект типа Series, содержащий уникальные значения 
и их частоты (количество повторений).
2 - Оставляем только те строки, где значение появляется более одного раза (используя лямбду-функцию внутри квадратных скобок).
Лямбда-функция используется для фильтрации результата. В коде "lambda x: x > 1" параметр x: каждый элемент из новой серии,
возвращённой функцией value_counts().
Эти элементы представляют собой частоту повторения каждого уникального значения.
Условие x > 1: выбирает только те элементы, где частота больше единицы (то есть числа, которые повторялись минимум дважды).
3 - Затем считаем длину полученного индекса, что даст нам итоговое количество повторяющихся чисел.
Применяем атрибут .index, чтобы получить сами повторяющиеся значения.
Так как индексами в серии, полученной с помощью метода "value_counts", являются сами уникальные значения (без учёта частоты).
Таким образом, получаем список самих повторяющихся чисел"""
number_of_repeats = len(frequent_values)
# затем считаем длину полученного индекса, что даст нам итоговое количество повторяющихся чисел
print("Количество повторяющихся значений равно: ", number_of_repeats)


# определим максимальное значение с помощью встроенной функции max()
Series_max = max(series_dataset)
print("Максимальное значение:", Series_max)

# определим сумму чисел с помощью встроенной функции sum()
Series_sum = sum(series_dataset)
print("Сумма чисел =", Series_sum)


# расчет среднеквадратического отклонения
Series_std  = series_dataset.std()
print("Среднеквадратическое отклонение: ", Series_std)


""" 3) Этап задания: Визуализировать данные с помощью стандартных библиотек по заданным критериям__________________"""
# # # # 1. -----> построить линейный график

# создаем линейный график и настраиваем его параметры
plt.figure(figsize=(10, 6))  # задаем размер окна
plt.plot(series_dataset, color='blue')  # Выбираем цвет
plt.title('Line chart')  # Добавили заголовок для графика
plt.xlabel('Index')  # Подписали ось X
plt.ylabel('Value')  # Подписали ось Y
plt.grid(True)  # включаем сетку (линии на обеих осях)
plt.show()    #  функция plt.show() отображает график на экране

# # # # 2. -----> - построить гистограмму (прямоугольную), округлив значения набора данных до сотен.

# округляем значения до сотен, для удобства используем возможности библиотеки numpy
rounded_series = np.round(series_dataset/100) * 100
# round - это функция, которая позволяет округлять числа до указанного количества знаков после запятой

# настраиваем гистограмма с округленными значениями
plt.figure(figsize=(10, 6))  # задаем размер окна
plt.hist(rounded_series, bins=range(-10000, 10001, 200), color='skyblue', edgecolor='black')
#  plt.hist() - функция в библиотеке Matplotlib которая позволяет создавать гистограммы.
#  bins - является единицей измерения интервалов в гистограмме
plt.title('Histogram') # добавили заголовок нашей гистограммы
plt.xlabel('Rounded value') # подписали ось X
plt.ylabel('Frequency') # подписали ось Y
plt.grid(axis='y') # включаем линию сетки по оси Y
plt.show() #  отображаем гистограмму на экране

"""4) Этап задания: Сформировать Dataframe из данных Series и добавить к этим данным  столбцы по возр-ию и по убыв-ию"""

# В ходе работы я столкнулся с проблемой на данном этапе, которая вела к полному дублированию отсортированных значений
# и наложению линий графика друг на друга.
# Что бы избежать этой ошибки применим метод .reset_index(drop=True)
sorted_ascending = series_dataset.sort_values().reset_index(drop=True)
sorted_descending = series_dataset.sort_values(ascending=False).reset_index(drop=True)
# метод .reset_index(drop=True) удаляет старый индекс и создаёт новый порядковый индекс, начиная с нуля.
# Это гарантирует, что индексы в каждой колонке совпадают, и предотвращается путаница с исходными индексами,
# оставшимися от оригинального объекта Series.
# Без сброса индекса (при сохранении старого индекса) каждый столбец сохраняет оригинальную последовательность индексов,
# что ведет к наложению графиков.

# формируем DataFrame
data_frame = pd.DataFrame({
    'Original': series_dataset.reset_index(drop=True),
    'Sorted ascending': sorted_ascending,
    'Sorted descending': sorted_descending
})

# выводим отсортированную серию по возрастанию
print(f"Отсортированные значения по возрастанию:\n{data_frame['Sorted ascending']}")

# выводим отсортированную серию по убыванию
print(f"Отсортированные значения по убыванию:\n{data_frame['Sorted descending']}")


""" 5) Этап задания: Визуализировать данные, полученные в результате промежуточного анализа (вычислений)_________"""

# визуализируем два линейных графика на одной фигуре
fig, ax = plt.subplots(figsize=(12, 6))

# график отсортированных значений по возрастанию
ax.plot(data_frame.index, data_frame['Sorted ascending'], label='Ascending sort', color='red')

# график отсортированных значений по убыванию
ax.plot(data_frame.index, data_frame['Sorted descending'], label='Descending sort', color='blue')

# настройка подписей на графике
ax.set_title('Comparison of ascending and descending sorted values')
ax.set_xlabel('Index')
ax.set_ylabel('Values')
ax.legend(loc='best')

# показываем график
plt.show()